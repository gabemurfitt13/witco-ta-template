diff --git a/index.html b/index.html
index d8d0cf18bd1c0aebbcb781bb30afc22747314245..8a2fd5fa81638f2d9779b7024cb6e2e16b35ac8f 100644
--- a/index.html
+++ b/index.html
@@ -444,52 +444,50 @@ const E = {
   clientDebug: el("clientDebug"),
   coachDebug: el("coachDebug"),
   specDebug: el("specDebug"),
 
   unlockName: el("unlockName"),
   unlockPin: el("unlockPin"),
   unlockAt: el("unlockAt"),
   unlockBtn: el("unlockBtn"),
   relockBtn: el("relockBtn"),
 
   saveNow: el("saveNow"),
   resumeDraft: el("resumeDraft"),
   exportJson: el("exportJson"),
   importJson: el("importJson"),
   wipeAll: el("wipeAll"),
   submitSupabase: el("submitSupabase"),
   reviewLoad: el("reviewLoad"),
   reviewKickBack: el("reviewKickBack"),
 
   addClientBtn: el("addClientBtn"),
   editClientBtn: el("editClientBtn"),
   demoBtn: el("demoBtn"),
 
   errorBox: el("errorBox"),
   errorList: el("errorList"),
-
-  submitSupabase: el("submitSupabase"),
   reloadClientsSupabase: el("reloadClientsSupabase"),
 
   authPill: el("authPill"),
   openLogin: el("openLogin"),
   logoutBtn: el("logoutBtn"),
 
   authOverlay: el("authOverlay"),
   authEmail: el("authEmail"),
   authPass: el("authPass"),
   authLoginBtn: el("authLoginBtn"),
   authCloseBtn: el("authCloseBtn"),
   authMsg: el("authMsg")
 };
 
 const formState = {
   lockState: "unlocked", // unlocked | locked | final
   sigs: {
     client: { printed:"", signedAt:"", dataUrl:"", strokes:0 },
     coach:  { printed:"", signedAt:"", dataUrl:"", strokes:0 },
     spec:   { printed:"", signedAt:"", dataUrl:"", strokes:0 }
   }
 };
 
 function setSaveState(text, kind="") {
   E.saveState.textContent = text;
@@ -504,93 +502,108 @@ function setLockPill() {
   if (formState.lockState === "locked")   { E.lockPill.textContent="Locked"; E.lockPill.classList.add("bad"); }
   if (formState.lockState === "final")    { E.lockPill.textContent="FINAL"; E.lockPill.classList.add("bad"); }
 }
 
 /* -------------------- AUTH UI -------------------- */
 function showAuthOverlay(show=true){
   E.authOverlay.style.display = show ? "flex" : "none";
   E.authMsg.style.display = "none";
   if (show) setTimeout(()=>E.authEmail.focus(), 50);
 }
 function setAuthPill(text, kind){
   E.authPill.textContent = text;
   E.authPill.classList.remove("bad","good","warn");
   E.authPill.classList.add(kind || "bad");
 }
 function showAuthMsg(msg){
   E.authMsg.textContent = msg;
   E.authMsg.style.display = "block";
 }
 
 async function refreshSessionAndUI(){
   const { data, error } = await sb.auth.getSession();
   if (error) {
     setAuthPill("Auth error", "bad");
     currentUser = null;
+    currentUserEmail = "";
+    isSpecialist = false;
+    appMode = "coach";
+    syncSigBadges();
     return;
   }
   const session = data?.session || null;
   if (!session) {
     currentUser = null;
+    currentUserEmail = "";
+    isSpecialist = false;
+    appMode = "coach";
     setAuthPill("Not signed in", "bad");
+    syncSigBadges();
     return;
   }
   currentUser = session.user;
+  currentUserEmail = (currentUser?.email || "").toLowerCase();
+  isSpecialist = SPECIALIST_EMAILS.map(e => e.toLowerCase()).includes(currentUserEmail);
   const email = currentUser?.email || "Signed in";
   setAuthPill(email, "good");
+  syncSigBadges();
 }
 
 E.openLogin.addEventListener("click", ()=>showAuthOverlay(true));
 E.authCloseBtn.addEventListener("click", ()=>showAuthOverlay(false));
 E.authLoginBtn.addEventListener("click", async ()=>{
   const email = (E.authEmail.value||"").trim();
   const password = (E.authPass.value||"").trim();
   if (!email || !password) return showAuthMsg("Email and password required.");
 
   try{
     setAuthPill("Signing in…", "warn");
     const { error } = await sb.auth.signInWithPassword({ email, password });
     if (error) {
       setAuthPill("Not signed in", "bad");
       return showAuthMsg(error.message);
     }
     await refreshSessionAndUI();
     showAuthOverlay(false);
     setSaveState("Signed in", "good");
   } catch (e){
     setAuthPill("Not signed in", "bad");
     showAuthMsg(e?.message || String(e));
   }
 });
 
 E.logoutBtn.addEventListener("click", async ()=>{
   try{
     await sb.auth.signOut();
   } catch {}
   currentUser = null;
+  currentUserEmail = "";
+  isSpecialist = false;
+  appMode = "coach";
   setAuthPill("Not signed in", "bad");
   setSaveState("Signed out", "warn");
+  syncSigBadges();
 });
 
 /* -------------------- VALIDATION UI -------------------- */
 function clearValidationUI() {
   document.querySelectorAll(".invalid").forEach(n => n.classList.remove("invalid"));
   E.errorList.innerHTML = "";
   E.errorBox.style.display = "none";
 }
 function showErrors(errors) {
   E.errorList.innerHTML = "";
   errors.forEach(e => {
     const li = document.createElement("li");
     li.textContent = e.msg;
     E.errorList.appendChild(li);
     if (e.node) e.node.classList.add("invalid");
   });
   E.errorBox.style.display = errors.length ? "block" : "none";
   if (errors.length) E.errorBox.scrollIntoView({ behavior:"smooth", block:"start" });
 }
 
 function usToISO(us) {
   const s = (us || "").trim();
   const m = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(s);
   if (!m) return "";
   return `${m[3]}-${m[1].padStart(2,"0")}-${m[2].padStart(2,"0")}`;
@@ -1207,102 +1220,50 @@ E.saveNow.addEventListener("click", ()=>{
   setSaveState("Saved","good");
 });
 E.resumeDraft.addEventListener("click", ()=>{
   const cid=currentClientId();
   if(!cid) return;
 
   const raw = localStorage.getItem(storageKeyFor(cid));
   if(!raw) return alert("No draft found for this client on this device.");
 
   try {
     apply(JSON.parse(raw));
     setSaveState("Draft resumed", "good");
   } catch {
     alert("Draft data is corrupted and couldn't be loaded.");
   }
 });
 E.exportJson.addEventListener("click", ()=>{
   const data=snapshot();
   const safe=(data.clientName||"client").replace(/[^a-z0-9]+/gi,"_").slice(0,40);
   download(`TA_${safe}_${data.entryDateISO||"no_date"}.json`, JSON.stringify(data,null,2));
 });
 E.importJson.addEventListener("click", ()=>{
   const raw=prompt("Paste JSON:");
   if(!raw) return;
   try{ apply(JSON.parse(raw)); autosave(); setSaveState("Imported","good"); } catch { alert("Invalid JSON"); }
-});
-  E.submitSupabase.addEventListener("click", async ()=>{
-  try {
-    // Require both signatures before submit
-    const v = validateRequiredForSigning();
-    if (!v.ok) return;
-
-    if (!formState.sigs.client.dataUrl) return alert("Client must sign first.");
-    if (!formState.sigs.coach.dataUrl) return alert("Coach must sign next.");
-
-    // Hard-lock locally immediately
-    formState.lockState = "final";
-    updateLockUI();
-
-    // Build record
-    const snap = snapshot();
-
-    // IMPORTANT: ensure JSON object, not weird references
-    const cleanSnap = JSON.parse(JSON.stringify(snap));
-
-    // You need a Supabase clients table mapping, but if you don't have it yet,
-    // we can store local clientId for now.
-    const clientId = cleanSnap.clientId || "";
-    const { data: userData } = await sb.auth.getUser();
-    const uid = userData?.user?.id;
-    if (!uid) return alert("Not logged in.");
-
-    const record = {
-      client_id: String(clientId),
-      coach_user_id: uid,
-      data: cleanSnap,
-      submitted_at: new Date().toISOString(),
-      client_signature_path: cleanSnap?.sigs?.client?.storagePath || null,
-      coach_signature_path: cleanSnap?.sigs?.coach?.storagePath || null,
-      spec_signature_path: null
-    };
-
-    const { error } = await sb.from("ta_records_v2").insert([record]);
-    if (error) throw error;
-
-    // Freeze everything after submit
-    setSaveState("Submitted. Locked for specialist review.", "good");
-    E.submitSupabase.disabled = true;
-    E.clientSign.disabled = true;
-    E.coachSign.disabled = true;
-    E.specFinal.disabled = true;
-  } catch (e) {
-    // If submit fails, unlock back so they can try again
-    formState.lockState = "locked";
-    updateLockUI();
-    alert("Submit failed: " + (e?.message || e));
-  }
 });
 E.reviewLoad.addEventListener("click", async ()=>{
   if (!isSpecialist) return alert("Not allowed.");
 
   const rid = prompt("Paste TA record ID (ta_records_v2.id):");
   if (!rid) return;
 
   try {
     const { data, error } = await sb
       .from("ta_records_v2")
       .select("*")
       .eq("id", rid)
       .single();
 
     if (error) throw error;
 
     apply(data.data);
     appMode = "review";
     currentRecordId = data.id;
     currentRecordStatus = data.status || "submitted";
 
     // Lock by default; specialist can unlock via PIN section (we’ll restrict next)
     formState.lockState = "locked";
     updateLockUI();
 
@@ -1409,50 +1370,54 @@ E.demoBtn.addEventListener("click", ()=>{
   onClientChange();
 });
 
 E.wipeAll.addEventListener("click", ()=>{
   if(!confirm("Wipe ALL local data on this device?")) return;
   localStorage.removeItem(CLIENTS_KEY);
   Object.keys(localStorage).forEach(k=>{
     if(k.startsWith(STORAGE_KEY_BASE+":")) localStorage.removeItem(k);
   });
   location.reload();
 });
 
 /* ---------- LOCK / UNLOCK ---------- */
 function lockEdits(){
   formState.lockState = "locked";
   updateLockUI();
   autosave();
 }
 function unlockEdits(){
   formState.lockState = "unlocked";
   E.unlockAt.value = nowStamp();
   updateLockUI();
   autosave();
 }
 E.unlockBtn.addEventListener("click", ()=>{
+  if (!formState.sigs.client.dataUrl) {
+    alert("Client must sign before unlocking for corrections.");
+    return;
+  }
   const pin = (E.unlockPin.value || "").trim();
   if(pin !== PIN_DEFAULT){
     alert("Incorrect PIN.");
     return;
   }
   unlockEdits();
   setSaveState("Unlocked for edits","good");
 });
 E.relockBtn.addEventListener("click", ()=>{
   lockEdits();
   setSaveState("Re-locked","good");
 });
 
 /* ---------- SIGNING ---------- */
 function finalizeClientSignature(){
   formState.sigs.client.printed = (E.clientPrinted.value||"").trim();
   formState.sigs.client.signedAt = nowStamp();
   E.clientSignedAt.textContent = formState.sigs.client.signedAt;
   formState.lockState = "locked";
   updateLockUI();
   syncSigBadges();
   autosave();
   setSaveState("Client signed. Form locked.","good");
 }
 function finalizeCoachSignature(){
@@ -1610,50 +1575,53 @@ async function uploadSignatureIfPresent(kind, dataUrl, clientName, entryDateISO)
   const blob = dataURLToBlob(dataUrl);
   if (!blob) return null;
 
   const safeClient = (clientName||"client").replace(/[^a-z0-9]+/gi,"_").slice(0,40);
   const safeDate = (entryDateISO||"no_date").replace(/[^0-9\-]/g,"");
   const filename = `${safeClient}/${safeDate}/${kind}_${Date.now()}.png`;
 
   const { data, error } = await sb.storage.from(SIG_BUCKET).upload(filename, blob, {
     contentType: "image/png",
     upsert: false
   });
   if (error) throw error;
   return data?.path || filename;
 }
 
 async function submitToSupabase(){
   await refreshSessionAndUI();
   if (!currentUser) {
     showAuthOverlay(true);
     throw new Error("You must be signed in to submit.");
   }
 
   const v = validateRequiredForSigning();
   if (!v.ok) throw new Error("Fix required fields before submitting.");
 
+  if (!formState.sigs.client.dataUrl) throw new Error("Client must sign first.");
+  if (!formState.sigs.coach.dataUrl) throw new Error("Coach must sign next.");
+
   const snap = snapshot();
 
   // Upload signatures (if present)
   const clientSigPath = await uploadSignatureIfPresent("client", snap.sigs?.client?.dataUrl, snap.clientName, snap.entryDateISO);
   const coachSigPath  = await uploadSignatureIfPresent("coach",  snap.sigs?.coach?.dataUrl,  snap.clientName, snap.entryDateISO);
   const specSigPath   = await uploadSignatureIfPresent("spec",   snap.sigs?.spec?.dataUrl,   snap.clientName, snap.entryDateISO);
 
   // Find matching client in Supabase by display_name (simple for now)
   const { data: crows, error: cerr } = await sb
     .from("clients")
     .select("id, display_name")
     .eq("display_name", snap.clientName)
     .limit(1);
 
   if (cerr) throw cerr;
 
   const supaClientId = crows?.[0]?.id;
   if (!supaClientId) {
     throw new Error("Client not found in Supabase. Click 'Reload Clients (Supabase)' or add the client in Supabase first.");
   }
 
   const record = {
     client_id: String(supaClientId),
     coach_user_id: currentUser.id,
     data: snap,
@@ -1661,53 +1629,45 @@ async function submitToSupabase(){
     coach_signature_path: coachSigPath,
     spec_signature_path: specSigPath
   };
 
  const TA_TABLE = "ta_records_v2";
 const { error } = await sb.from(TA_TABLE).insert([record]);
   if (error) throw error;
 
   setSaveState("Submitted to Supabase", "good");
 }
 
 E.submitSupabase.addEventListener("click", async ()=>{
   try{
     setSaveState("Submitting…", "warn");
     await submitToSupabase();
     alert("Submitted to Supabase successfully.");
   } catch (e){
     setSaveState("Submit failed", "bad");
     alert(e?.message || String(e));
   }
 });
 
 /* ---------- init ---------- */
 (async function init(){
   renderClientSelect();
-    // Determine current user email (Supabase auth)
-  try {
-    if (window.sb && sb?.auth?.getUser) {
-      const { data } = await sb.auth.getUser();
-      currentUserEmail = (data?.user?.email || "").toLowerCase();
-      isSpecialist = SPECIALIST_EMAILS.map(e => e.toLowerCase()).includes(currentUserEmail);
-    }
-  } catch {}
   const clients=getClients();
 
   if(clients.length){
     renderClientSelect(clients[0].id);
     onClientChange();
     setSaveState("Ready","good");
   } else {
     E.entryDateUS.value=todayUS();
     setSaveState("No clients loaded","bad");
     updateLockUI();
   }
   syncSigBadges();
   updateLockUI();
 
   // auth bootstrap
   refreshSessionAndUI().catch(()=>{});
 })();
 </script>
 </body>
 </html>
