<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Supported Employment Data Sheet (Web Form)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f7fb; color: #111; }
    .wrap { max-width: 1100px; margin: 16px auto; padding: 12px; }
    .card { background: #fff; border: 1px solid #e6e8f0; border-radius: 12px; padding: 12px; box-shadow: 0 2px 10px rgba(0,0,0,.04); }
    h1 { margin: 0 0 6px; font-size: 18px; }
    .sub { color: #555; font-size: 12px; margin-bottom: 10px; display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .pill { display: inline-block; padding: 5px 9px; border-radius: 999px; background: #f1f3ff; color: #223; font-size: 12px; border: 1px solid #e0e5ff; }
    .pill.bad { background:#fff1f1; border-color:#ffd3d3; color:#7a1111; }
    .pill.good { background:#eefbf3; border-color:#c7f0d8; color:#104a2a; }

    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; }
    .col-12 { grid-column: span 12; }
    .col-6  { grid-column: span 6; }
    .col-4  { grid-column: span 4; }
    .col-3  { grid-column: span 3; }
    .col-2  { grid-column: span 2; }

    label { display: block; font-size: 11px; color: #444; margin-bottom: 5px; }
    input, textarea, select {
      width: 100%; box-sizing: border-box; padding: 8px 9px;
      border: 1px solid #d7dbea; border-radius: 10px; background: #fff;
      font-size: 13px;
    }
    textarea { min-height: 54px; resize: none; overflow:hidden; }
    .tight textarea { min-height: 38px; }

    .rowhead { display: flex; align-items: baseline; justify-content: space-between; margin: 12px 0 6px; gap: 10px; }
    .rowhead h2 { margin: 0; font-size: 14px; }
    .hint { font-size: 11px; color: #666; line-height: 1.25; }

    table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    th, td { border-top: 1px solid #eef0f6; padding: 6px 6px; vertical-align: top; }
    th { text-align: left; font-size: 11px; color: #555; background: #fafbff; }
    .mono { font-variant-numeric: tabular-nums; }

    .btnbar { display: flex; gap: 8px; flex-wrap: wrap; }
    button {
      border: 1px solid #d7dbea; background: #111; color: #fff;
      padding: 8px 10px; border-radius: 10px; cursor: pointer; font-size: 13px;
    }
    button.secondary { background: #fff; color: #111; }
    button.danger { background: #b42318; border-color: #b42318; }
    button.warn { background: #b36b00; border-color: #b36b00; }
    button.ok { background:#157f3b; border-color:#157f3b; }
    .tiny { font-size: 12px; padding: 6px 8px; border-radius: 9px; }

    .footer { margin-top: 10px; font-size: 11px; color: #666; }

    /* Required field highlight */
    .req-bad { border-color:#b42318 !important; box-shadow:0 0 0 2px rgba(180,35,24,.12) !important; }
    tr.req-bad { outline: 2px solid rgba(180,35,24,.18); outline-offset: -2px; }

    /* Prompt line layout */
    .supportLines { display:flex; flex-direction:column; gap:6px; }
    .supportLine { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .supportLine select { flex: 1 1 120px; }
    .supportLine input { flex: 0 0 90px; }
    .supportLine button { flex: 0 0 auto; }

    /* Signatures */
    .sigGrid { display:grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .sigCard { border:1px solid #e6e8f0; border-radius:12px; padding:10px; background:#fff; }
    .sigTop { display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .sigTop b { font-size: 13px; }
    .sigMeta { font-size: 11px; color:#666; margin-top:6px; display:flex; gap:12px; flex-wrap:wrap; }
    .sigcanvas {
      width:100%;
      height:160px;
      border:1px dashed #cfd6ee;
      border-radius:10px;
      touch-action:none;
      display:block;
      background: linear-gradient(to bottom, transparent 0 78%, rgba(0,0,0,.08) 78% 79%, transparent 79% 100%);
    }

    /* Mobile: table -> card layout */
    @media (max-width: 720px) {
      .wrap { padding: 10px; }
      .grid { grid-template-columns: repeat(12, 1fr); }
      .col-6, .col-4, .col-3, .col-2 { grid-column: span 12; }

      table { display:block; }
      thead { display:none; }
      tbody, tr, td { display:block; width:100%; }
      tr { border:1px solid #eef0f6; border-radius:12px; padding:10px; margin:10px 0; background:#fff; }
      td { border:none; padding:6px 0; }
      td::before {
        content: attr(data-label);
        display:block;
        font-size:11px;
        color:#666;
        margin-bottom:4px;
      }
      .supportLine select { flex: 1 1 140px; }
      .supportLine input { flex: 0 0 90px; }
      td:last-child button { width: 100%; }

      .sigGrid { grid-template-columns: 1fr; }
    }

    @media print {
      body { background: #fff; }
      .wrap { margin: 0; padding: 0; }
      .card { box-shadow: none; border: none; border-radius: 0; padding: 0; }
      .btnbar, .footer, .manageRow { display: none !important; }
      input, textarea, select { border: 1px solid #bbb; }
      th { background: #eee !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      textarea { min-height: 32px; }
      .hint { font-size: 10px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Medicaid - DD Waivered Supported Employment Data Sheet</h1>
      <div class="sub">
        One form. Works on desktop + mobile. Saves locally per device (for now).
        <span class="pill" id="saveState">Ready</span>
        <span class="pill" id="lockStatePill">Unlocked</span>
      </div>

      <div class="grid">
        <div class="col-6">
          <label>Client</label>
          <select id="clientSelect"></select>
          <div class="manageRow" style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap;">
            <button class="secondary tiny" id="addClient" type="button">Add Client</button>
            <button class="secondary tiny" id="editClient" type="button">Edit Client</button>
            <button class="secondary tiny" id="loadDemo" type="button">Load Demo Clients</button>
          </div>
        </div>

        <div class="col-3">
          <label>Plan Start (locked)</label>
          <input id="planStart" type="date" readonly />
        </div>
        <div class="col-3">
          <label>Plan End (locked)</label>
          <input id="planEnd" type="date" readonly />
        </div>

        <div class="col-4">
          <label>Work Location</label>
          <input id="workLocation" placeholder="e.g., Albertsons" />
        </div>
        <div class="col-4">
          <label>Date</label>
          <input id="entryDate" type="date" />
        </div>
        <div class="col-2">
          <label>Time In</label>
          <input id="timeIn" type="time" class="mono" />
        </div>
        <div class="col-2">
          <label>Time Out</label>
          <input id="timeOut" type="time" class="mono" />
        </div>

        <div class="col-12">
          <label>Total Time (auto, quarter-hours)</label>
          <input id="totalTime" readonly />
        </div>
      </div>

      <div class="rowhead">
        <h2>Prompt Codes</h2>
        <div class="hint">I = Independent · IR = Indirect Reminder · VI = Verbal Instruction · M = Model/Demo · P = Physical · R = Refusal</div>
      </div>

      <div class="rowhead">
        <h2>Duties and Tasks</h2>
        <div class="btnbar">
          <button class="secondary tiny" id="addTask" type="button">Add Task</button>
          <button class="secondary tiny" id="editTasks" type="button">Edit Tasks (template)</button>
        </div>
      </div>

      <table class="tight" id="tasksTable">
        <thead>
          <tr>
            <th style="width: 36%;">Task</th>
            <th style="width: 14%;">Support</th>
            <th>Note (short)</th>
            <th style="width: 90px;">Remove</th>
          </tr>
        </thead>
        <tbody id="tasksBody"></tbody>
      </table>

      <div class="rowhead">
        <h2>Goals (full text visible)</h2>
        <div class="btnbar">
          <button class="secondary tiny" id="addGoal" type="button">Add Goal</button>
          <button class="secondary tiny" id="editGoals" type="button">Edit Goals (template)</button>
        </div>
      </div>

      <table id="goalsTable">
        <thead>
          <tr>
            <th style="width: 42%;">Goal (full text)</th>
            <th style="width: 24%;">Prompts (code + count)</th>
            <th>Anecdotal Record</th>
            <th style="width: 90px;">Remove</th>
          </tr>
        </thead>
        <tbody id="goalsBody"></tbody>
      </table>

      <div class="rowhead">
        <h2>Additional Notes (optional)</h2>
      </div>
      <textarea id="additionalNotes" placeholder="Scheduling changes, job highlights, employment needs, etc."></textarea>

      <div class="rowhead">
        <h2>Signatures</h2>
        <div class="hint">Client, Coach, Specialist. Unlocking for edits clears signatures.</div>
      </div>

      <div class="sigGrid">
        <div class="sigCard">
          <div class="sigTop">
            <b>Client Signature</b>
            <span class="pill" id="clientSigStatus">Not signed</span>
          </div>
          <canvas class="sigcanvas" id="clientCanvas"></canvas>
          <div style="margin-top:8px;">
            <label>Printed name</label>
            <input id="clientPrinted" placeholder="Client printed name" />
            <div class="sigMeta">
              <span>Signed at: <span id="clientSignedAt">—</span></span>
            </div>
            <div class="btnbar" style="margin-top:8px;">
              <button class="secondary tiny" id="clientClear" type="button">Clear</button>
              <button class="tiny ok" id="clientSign" type="button">Sign (locks editing)</button>
            </div>
          </div>
        </div>

        <div class="sigCard">
          <div class="sigTop">
            <b>Coach Signature</b>
            <span class="pill" id="coachSigStatus">Not signed</span>
          </div>
          <canvas class="sigcanvas" id="coachCanvas"></canvas>
          <div style="margin-top:8px;">
            <label>Printed name</label>
            <input id="coachPrinted" placeholder="Coach printed name" />
            <div class="sigMeta">
              <span>Signed at: <span id="coachSignedAt">—</span></span>
            </div>
            <div class="btnbar" style="margin-top:8px;">
              <button class="secondary tiny" id="coachClear" type="button">Clear</button>
              <button class="tiny" id="coachSign" type="button">Sign</button>
            </div>
          </div>
        </div>

        <div class="sigCard">
          <div class="sigTop">
            <b>Specialist Signature</b>
            <span class="pill" id="specSigStatus">Not signed</span>
          </div>
          <canvas class="sigcanvas" id="specCanvas"></canvas>
          <div style="margin-top:8px;">
            <label>Printed name</label>
            <input id="specPrinted" placeholder="Specialist printed name" />
            <div class="sigMeta">
              <span>Signed at: <span id="specSignedAt">—</span></span>
            </div>
            <div class="btnbar" style="margin-top:8px;">
              <button class="secondary tiny" id="specClear" type="button">Clear</button>
              <button class="tiny warn" id="specFinal" type="button">Sign (FINAL lock)</button>
            </div>
          </div>
        </div>
      </div>

      <div class="rowhead">
        <h2>Unlock for Edits (PIN)</h2>
        <div class="hint">PIN is ONLY used to unlock editing. Coach signing is never blocked by PIN.</div>
      </div>

      <div class="grid" style="align-items:end;">
        <div class="col-4">
          <label>Specialist Name (for unlock log)</label>
          <input id="unlockName" placeholder="Specialist name" />
        </div>
        <div class="col-4">
          <label>PIN</label>
          <input id="unlockPin" type="password" placeholder="PIN" />
        </div>
        <div class="col-4">
          <label>Unlocked Date/Time (auto)</label>
          <input id="unlockAt" readonly />
        </div>
        <div class="col-12">
          <div class="btnbar">
            <button class="secondary" id="unlockBtn" type="button">Unlock for Corrections</button>
            <button class="secondary" id="relockBtn" type="button">Re-Lock After Edits</button>
          </div>
        </div>
      </div>

      <div class="btnbar" style="margin-top:10px;">
        <button id="saveNow" type="button">Save</button>
        <button class="secondary" id="exportJson" type="button">Export JSON</button>
        <button class="secondary" id="importJson" type="button">Import JSON</button>
        <button class="secondary" id="printPage" type="button">Print / Save as PDF</button>
        <button class="danger" id="wipeAll" type="button">Wipe Local Data (this device)</button>
      </div>

      <div class="footer">
        Local storage: clearing browser data nukes saved forms on that device. Computers are loyal like that.
      </div>
    </div>
  </div>

<script>
  // ---- Defaults / constants ----
  const DEFAULT_TASKS = [
    "Clock in & out",
    "Bag groceries for customers",
    'Return "go-backs" to the appropriate shelves',
    "Get carts from parking lot",
    "Cleaning tasks as assigned by management"
  ];

  const DEFAULT_GOALS = [
    "When the client stops at customer service to get water, they will independently redirect back to work tasks within 1 minute, 50% of the time for 3 consecutive months.",
    "Client will independently put quality into work when retrieving carts by organizing them in the cart corral based on type and/or size, 90% of the time for 3 consecutive months.",
    "When walking the sales floor, client will independently recognize when baskets need restocked and complete the task 90% of the time for 3 consecutive months."
  ];

  const SUPPORT_LEVELS = ["", "I", "IR", "VI", "M", "P", "R"];

  const CLIENTS_KEY = "witco_clients_v2";
  const STORAGE_KEY_BASE = "witco_supported_employment_form_v6";
  const PIN_DEFAULT = "2468"; // change this to whatever you want

  const el = (id) => document.getElementById(id);

  // Lock states:
  // unlocked: can edit
  // locked: client signed (editing blocked unless PIN unlock)
  // final: specialist signed final (editing blocked, no unlock)
  function setSaveState(text, kind="") {
    const p = el("saveState");
    p.textContent = text;
    p.classList.remove("bad","good");
    if (kind === "bad") p.classList.add("bad");
    if (kind === "good") p.classList.add("good");
  }

  function setLockPill(state) {
    const p = el("lockStatePill");
    p.classList.remove("bad","good");
    if (state === "unlocked") { p.textContent = "Unlocked"; p.classList.add("good"); }
    else if (state === "locked") { p.textContent = "Locked"; p.classList.add("bad"); }
    else if (state === "final") { p.textContent = "FINAL Locked"; p.classList.add("bad"); }
    else { p.textContent = "Unlocked"; }
  }

  function storageKeyFor(clientId) {
    return `${STORAGE_KEY_BASE}:${clientId}`;
  }

  function getClients() {
    try { return JSON.parse(localStorage.getItem(CLIENTS_KEY) || "[]"); }
    catch { return []; }
  }
  function saveClients(clients) {
    localStorage.setItem(CLIENTS_KEY, JSON.stringify(clients));
  }
  function getClientById(id) {
    return getClients().find(c => c.id === id);
  }
  function currentClientId() {
    return el("clientSelect").value || "";
  }

  function renderClientSelect(selectedId = null) {
    const clients = getClients();
    el("clientSelect").innerHTML = "";

    if (clients.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "No clients loaded";
      el("clientSelect").appendChild(opt);
      return;
    }

    clients.forEach(c => {
      const opt = document.createElement("option");
      opt.value = c.id;
      opt.textContent = c.name;
      el("clientSelect").appendChild(opt);
    });

    el("clientSelect").value = selectedId || clients[0].id;
  }

  // ---- Date helpers ----
  function todayISO() {
    const d = new Date();
    return d.toISOString().slice(0,10);
  }
  function nowStamp() {
    return new Date().toLocaleString();
  }

  function normalizeToISO(usDate) {
    // Accept MM/DD/YYYY and convert to YYYY-MM-DD
    const parts = (usDate || "").trim().split("/");
    if (parts.length !== 3) return (usDate || "").trim();
    const [mm, dd, yyyy] = parts;
    if (!yyyy || yyyy.length < 4) return (usDate || "").trim();
    return `${yyyy}-${(mm||"").padStart(2,"0")}-${(dd||"").padStart(2,"0")}`;
  }

  // ---- Time calc ----
  function minutesBetween(t1, t2) {
    if (!t1 || !t2) return null;
    const [h1,m1] = t1.split(":").map(Number);
    const [h2,m2] = t2.split(":").map(Number);
    if ([h1,m1,h2,m2].some(x => Number.isNaN(x))) return null;
    let a = h1*60+m1, b = h2*60+m2;
    if (b < a) b += 24*60; // wrap past midnight
    return b - a;
  }
  function minutesToQuarterHours(minutes) {
    if (minutes == null) return "";
    const roundedMinutes = Math.round(minutes / 15) * 15;
    const decimalHours = roundedMinutes / 60;
    return decimalHours.toFixed(2);
  }
  function recalcTotalTime() {
    const mins = minutesBetween(el("timeIn").value, el("timeOut").value);
    el("totalTime").value = minutesToQuarterHours(mins);
  }

  // ---- UI builders ----
  function makeSupportSelect(value="") {
    const s = document.createElement("select");
    SUPPORT_LEVELS.forEach(v => {
      const o = document.createElement("option");
      o.value = v; o.textContent = v || "(select)";
      if (v === value) o.selected = true;
      s.appendChild(o);
    });
    return s;
  }

  function autosizeTA(ta) {
    ta.style.height = "auto";
    ta.style.height = (ta.scrollHeight) + "px";
  }

  function setPlanDatesLocked(planStart, planEnd) {
    el("planStart").value = planStart || "";
    el("planEnd").value = planEnd || "";
    el("planStart").disabled = true;
    el("planEnd").disabled = true;
  }

  // ---- Tasks table ----
  function addTaskRow(tbody, rowData) {
    const tr = document.createElement("tr");

    const tdTitle = document.createElement("td");
    tdTitle.setAttribute("data-label","Task");
    const titleInput = document.createElement("input");
    titleInput.value = rowData.title || "";
    titleInput.placeholder = "Task...";
    tdTitle.appendChild(titleInput);

    const tdSupport = document.createElement("td");
    tdSupport.setAttribute("data-label","Support");
    const supportSelect = makeSupportSelect(rowData.support || "");
    tdSupport.appendChild(supportSelect);

    const tdNote = document.createElement("td");
    tdNote.setAttribute("data-label","Note (short)");
    const noteInput = document.createElement("input");
    noteInput.value = rowData.note || "";
    noteInput.placeholder = "Short note...";
    tdNote.appendChild(noteInput);

    const tdRemove = document.createElement("td");
    tdRemove.setAttribute("data-label","Remove");
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "secondary tiny";
    btn.textContent = "Remove";
    btn.addEventListener("click", () => { tr.remove(); autosave(); });
    tdRemove.appendChild(btn);

    tr.appendChild(tdTitle);
    tr.appendChild(tdSupport);
    tr.appendChild(tdNote);
    tr.appendChild(tdRemove);

    [titleInput, supportSelect, noteInput].forEach(node => {
      node.addEventListener("input", autosave);
      node.addEventListener("change", autosave);
    });

    tbody.appendChild(tr);
  }

  function getTasks() {
    const rows = [...el("tasksBody").querySelectorAll("tr")];
    return rows.map(tr => {
      const inputs = tr.querySelectorAll("input, select");
      return { title: inputs[0].value.trim(), support: inputs[1].value, note: inputs[2].value.trim() };
    });
  }

  function setTasks(data) {
    el("tasksBody").innerHTML = "";
    (data || []).forEach(d => addTaskRow(el("tasksBody"), d));
  }

  // ---- Goals table ----
  function addPromptLine(container, promptData) {
    const line = document.createElement("div");
    line.className = "supportLine";

    const sel = makeSupportSelect(promptData?.code || "");
    const cnt = document.createElement("input");
    cnt.type = "number";
    cnt.min = "1";
    cnt.step = "1";
    cnt.placeholder = "Count";
    cnt.value = (promptData?.count ?? 1);

    const rm = document.createElement("button");
    rm.type = "button";
    rm.className = "secondary tiny";
    rm.textContent = "X";
    rm.addEventListener("click", () => { line.remove(); autosave(); });

    [sel, cnt].forEach(n => {
      n.addEventListener("change", autosave);
      n.addEventListener("input", autosave);
    });

    line.appendChild(sel);
    line.appendChild(cnt);
    line.appendChild(rm);
    container.appendChild(line);
  }

  function addGoalRow(tbody, rowData) {
    const tr = document.createElement("tr");

    // Goal text
    const tdGoal = document.createElement("td");
    tdGoal.setAttribute("data-label","Goal (full text)");
    const goalTA = document.createElement("textarea");
    goalTA.value = rowData.title || "";
    goalTA.placeholder = "Goal (full text)...";
    tdGoal.appendChild(goalTA);

    // Prompts (multi)
    const tdPrompts = document.createElement("td");
    tdPrompts.setAttribute("data-label","Prompts (code + count)");
    const promptsWrap = document.createElement("div");
    promptsWrap.className = "supportLines";

    const prompts = Array.isArray(rowData.prompts) ? rowData.prompts : [];
    if (prompts.length) {
      prompts.forEach(p => addPromptLine(promptsWrap, p));
    } else {
      addPromptLine(promptsWrap, { code:"", count:1 });
    }

    const addP = document.createElement("button");
    addP.type = "button";
    addP.className = "secondary tiny";
    addP.textContent = "+ Prompt";
    addP.addEventListener("click", () => { addPromptLine(promptsWrap, { code:"", count:1 }); autosave(); });

    tdPrompts.appendChild(promptsWrap);
    tdPrompts.appendChild(addP);

    // Anecdotal
    const tdNote = document.createElement("td");
    tdNote.setAttribute("data-label","Anecdotal Record");
    const noteTA = document.createElement("textarea");
    noteTA.value = rowData.note || "";
    noteTA.placeholder = "Anecdotal record...";
    tdNote.appendChild(noteTA);

    // Remove
    const tdRemove = document.createElement("td");
    tdRemove.setAttribute("data-label","Remove");
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "secondary tiny";
    btn.textContent = "Remove";
    btn.addEventListener("click", () => { tr.remove(); autosave(); });
    tdRemove.appendChild(btn);

    tr.appendChild(tdGoal);
    tr.appendChild(tdPrompts);
    tr.appendChild(tdNote);
    tr.appendChild(tdRemove);

    const resizeAll = () => { autosizeTA(goalTA); autosizeTA(noteTA); };
    goalTA.addEventListener("input", () => { resizeAll(); autosave(); });
    noteTA.addEventListener("input", () => { resizeAll(); autosave(); });

    setTimeout(resizeAll, 0);
    tbody.appendChild(tr);
  }

  function getGoals() {
    const rows = [...el("goalsBody").querySelectorAll("tr")];
    return rows.map(tr => {
      const tas = tr.querySelectorAll("textarea");
      const goalText = tas[0]?.value.trim() || "";
      const noteText = tas[1]?.value.trim() || "";

      const promptLines = [...tr.querySelectorAll(".supportLine")];
      const prompts = promptLines.map(line => {
        const sel = line.querySelector("select");
        const cnt = line.querySelector('input[type="number"]');
        return { code: sel?.value || "", count: parseInt(cnt?.value || "0", 10) || 0 };
      });

      return { title: goalText, prompts, note: noteText };
    });
  }

  function setGoals(data) {
    el("goalsBody").innerHTML = "";
    (data || []).forEach(d => addGoalRow(el("goalsBody"), d));
  }

  // ---- Lock / edit gating ----
  function isLocked(state) { return state === "locked" || state === "final"; }

  function setEditingEnabled(enabled) {
    // Disable most inputs when locked, but keep signing available.
    const ids = ["workLocation","entryDate","timeIn","timeOut","additionalNotes","clientPrinted","coachPrinted","specPrinted"];
    ids.forEach(id => {
      if (!el(id)) return;
      // Printed names should still be editable for signing even when locked
      if (id.endsWith("Printed")) return;
      el(id).disabled = !enabled;
    });

    // disable add/remove and table inputs
    const disableIn = (root, on) => {
      root.querySelectorAll("input, textarea, select, button").forEach(node => {
        // don't disable signature buttons/canvas stuff here
        node.disabled = on;
      });
    };

    // Only lock the tasks/goals editing, not the signature actions
    const tasksRoot = el("tasksBody");
    const goalsRoot = el("goalsBody");

    tasksRoot.querySelectorAll("input, select, button").forEach(n => n.disabled = !enabled);
    goalsRoot.querySelectorAll("textarea, select, input, button").forEach(n => n.disabled = !enabled);

    el("addTask").disabled = !enabled;
    el("addGoal").disabled = !enabled;
    el("editTasks").disabled = !enabled;
    el("editGoals").disabled = !enabled;

    // Save still allowed if enabled, blocked by validation if not complete anyway
    el("saveNow").disabled = !enabled;
  }

  function updateLockUI() {
    const s = formState.lockState || "unlocked";
    setLockPill(s);
    // final lock: no unlock
    el("unlockBtn").disabled = (s === "final");
    el("relockBtn").disabled = (s === "final");
    // editing enabled only if unlocked
    setEditingEnabled(s === "unlocked");
  }

  // ---- Signature pad ----
  function createSigPad(canvasId, getData, setData) {
    const canvas = el(canvasId);
    const ctx = canvas.getContext("2d");
    let drawing = false;
    let last = null;

    function resizeToCSS() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      // Set backing store size
      canvas.width = Math.max(1, Math.round(rect.width * dpr));
      canvas.height = Math.max(1, Math.round(rect.height * dpr));

      // Reset transform and scale
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Redraw from saved image if exists
      redraw();
    }

    function clear() {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);
      last = null;
    }

    function redraw() {
      clear();
      const dataUrl = getData();
      if (!dataUrl) return;
      const img = new Image();
      img.onload = () => {
        const rect = canvas.getBoundingClientRect();
        ctx.drawImage(img, 0, 0, rect.width, rect.height);
      };
      img.src = dataUrl;
    }

    function posFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      return { x, y };
    }

    function start(e) {
      if (canvas.disabled) return;
      drawing = true;
      last = posFromEvent(e);
      canvas.setPointerCapture?.(e.pointerId);
      e.preventDefault();
    }

    function move(e) {
      if (!drawing) return;
      const p = posFromEvent(e);
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      ctx.strokeStyle = "#111";
      ctx.beginPath();
      ctx.moveTo(last.x, last.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      last = p;
      e.preventDefault();
    }

    function end(e) {
      if (!drawing) return;
      drawing = false;
      last = null;
      // Persist drawing to dataURL for storage
      const rect = canvas.getBoundingClientRect();
      const tmp = document.createElement("canvas");
      tmp.width = Math.max(1, Math.round(rect.width));
      tmp.height = Math.max(1, Math.round(rect.height));
      const tctx = tmp.getContext("2d");
      // draw scaled down current canvas
      tctx.drawImage(canvas, 0, 0, tmp.width, tmp.height);
      setData(tmp.toDataURL("image/png"));
      autosave();
      e.preventDefault();
    }

    canvas.addEventListener("pointerdown", start);
    canvas.addEventListener("pointermove", move);
    canvas.addEventListener("pointerup", end);
    canvas.addEventListener("pointercancel", end);

    window.addEventListener("resize", resizeToCSS);
    setTimeout(resizeToCSS, 0);

    return { canvas, redraw, clear, resizeToCSS };
  }

  // ---- Validation ----
  function clearRequiredHighlights() {
    document.querySelectorAll(".req-bad").forEach(x => x.classList.remove("req-bad"));
  }
  function markBad(node) {
    if (!node) return;
    node.classList.add("req-bad");
  }

  function validateForm({ forAction="save" } = {}) {
    clearRequiredHighlights();
    const missing = [];

    // client
    if (!currentClientId()) { missing.push("Client must be selected"); markBad(el("clientSelect")); }

    // plan dates (locked but required)
    if (!el("planStart").value) { missing.push("Plan Start is required"); markBad(el("planStart")); }
    if (!el("planEnd").value) { missing.push("Plan End is required"); markBad(el("planEnd")); }

    // work fields
    if (!el("workLocation").value.trim()) { missing.push("Work Location is required"); markBad(el("workLocation")); }
    if (!el("entryDate").value) { missing.push("Date is required"); markBad(el("entryDate")); }
    if (!el("timeIn").value) { missing.push("Time In is required"); markBad(el("timeIn")); }
    if (!el("timeOut").value) { missing.push("Time Out is required"); markBad(el("timeOut")); }
    if (!el("totalTime").value) { missing.push("Total Time must calculate"); markBad(el("totalTime")); }

    // tasks required (at least 1)
    const taskRows = [...el("tasksBody").querySelectorAll("tr")];
    if (taskRows.length === 0) missing.push("At least 1 Task is required");
    taskRows.forEach((tr, i) => {
      const title = tr.querySelector('td[data-label="Task"] input')?.value.trim() || "";
      const sup = tr.querySelector('td[data-label="Support"] select')?.value || "";
      if (!title) { missing.push(`Task #${i+1}: Task text required`); markBad(tr.querySelector('td[data-label="Task"] input')); }
      if (!sup) { missing.push(`Task #${i+1}: Support code required`); markBad(tr.querySelector('td[data-label="Support"] select')); }
    });

    // goals required (at least 1)
    const goalRows = [...el("goalsBody").querySelectorAll("tr")];
    if (goalRows.length === 0) missing.push("At least 1 Goal is required");
    goalRows.forEach((tr, i) => {
      const goalTA = tr.querySelector('td[data-label="Goal (full text)"] textarea');
      const goalText = goalTA?.value.trim() || "";
      if (!goalText) { missing.push(`Goal #${i+1}: Goal text required`); markBad(goalTA); }

      const promptLines = [...tr.querySelectorAll(".supportLine")];
      if (promptLines.length === 0) {
        missing.push(`Goal #${i+1}: At least 1 prompt required`);
        tr.classList.add("req-bad");
      } else {
        let anyValid = false;
        promptLines.forEach(line => {
          const code = line.querySelector("select")?.value || "";
          const count = parseInt(line.querySelector('input[type="number"]')?.value || "0", 10) || 0;
          if (code && count > 0) anyValid = true;
        });
        if (!anyValid) {
          missing.push(`Goal #${i+1}: Prompt must have code + count (ex: IR x5)`);
          const first = promptLines[0];
          markBad(first.querySelector("select"));
          markBad(first.querySelector('input[type="number"]'));
        }
      }
    });

    // Signature action requirements
    if (forAction === "clientSign") {
      if (!el("clientPrinted").value.trim()) { missing.push("Client printed name required"); markBad(el("clientPrinted")); }
      if (!formState.sigs.client.dataUrl) { missing.push("Client signature must be drawn"); markBad(el("clientCanvas")); }
    }
    if (forAction === "coachSign") {
      if (!el("coachPrinted").value.trim()) { missing.push("Coach printed name required"); markBad(el("coachPrinted")); }
      if (!formState.sigs.coach.dataUrl) { missing.push("Coach signature must be drawn"); markBad(el("coachCanvas")); }
    }
    if (forAction === "specFinal") {
      if (!el("specPrinted").value.trim()) { missing.push("Specialist printed name required"); markBad(el("specPrinted")); }
      if (!formState.sigs.spec.dataUrl) { missing.push("Specialist signature must be drawn"); markBad(el("specCanvas")); }
    }

    return { ok: missing.length === 0, missing };
  }

  function blockIfInvalid(actionLabel, options) {
    const { ok, missing } = validateForm(options);
    if (ok) return true;
    alert(
      `${actionLabel} blocked.\n\nMissing / incomplete:\n- ` +
      missing.join("\n- ")
    );
    setSaveState("Fix required fields", "bad");
    return false;
  }

  // ---- Form state ----
  const formState = {
    lockState: "unlocked",
    unlock: { name:"", at:"" },
    sigs: {
      client: { printed:"", signedAt:"", dataUrl:"" },
      coach: { printed:"", signedAt:"", dataUrl:"" },
      spec:  { printed:"", signedAt:"", dataUrl:"" }
    }
  };

  function clearAllSignatures() {
    formState.sigs.client = { printed: el("clientPrinted").value.trim(), signedAt:"", dataUrl:"" };
    formState.sigs.coach  = { printed: el("coachPrinted").value.trim(),  signedAt:"", dataUrl:"" };
    formState.sigs.spec   = { printed: el("specPrinted").value.trim(),   signedAt:"", dataUrl:"" };

    el("clientSignedAt").textContent = "—";
    el("coachSignedAt").textContent = "—";
    el("specSignedAt").textContent = "—";
    setSigStatus("client", false);
    setSigStatus("coach", false);
    setSigStatus("spec", false);

    sigPads.client.clear(); sigPads.coach.clear(); sigPads.spec.clear();
  }

  function setSigStatus(which, signed) {
    const map = {
      client: el("clientSigStatus"),
      coach: el("coachSigStatus"),
      spec: el("specSigStatus"),
    };
    const pill = map[which];
    pill.classList.remove("bad","good");
    if (signed) { pill.textContent = "Signed"; pill.classList.add("good"); }
    else { pill.textContent = "Not signed"; pill.classList.add("bad"); }
  }

  // ---- Snapshot / apply ----
  function snapshot() {
    const cid = currentClientId();
    const client = getClientById(cid);
    return {
      version: 6,
      clientId: cid,
      clientName: client?.name || "",
      planStart: el("planStart").value,
      planEnd: el("planEnd").value,
      workLocation: el("workLocation").value,
      entryDate: el("entryDate").value,
      timeIn: el("timeIn").value,
      timeOut: el("timeOut").value,
      totalTime: el("totalTime").value,
      tasks: getTasks(),
      goals: getGoals(),
      additionalNotes: el("additionalNotes").value,

      lockState: formState.lockState,
      unlock: {
        name: el("unlockName").value,
        at: el("unlockAt").value
      },
      sigs: {
        client: { printed: el("clientPrinted").value, signedAt: formState.sigs.client.signedAt, dataUrl: formState.sigs.client.dataUrl },
        coach:  { printed: el("coachPrinted").value,  signedAt: formState.sigs.coach.signedAt,  dataUrl: formState.sigs.coach.dataUrl },
        spec:   { printed: el("specPrinted").value,   signedAt: formState.sigs.spec.signedAt,   dataUrl: formState.sigs.spec.dataUrl }
      }
    };
  }

  function apply(data) {
    // Plan dates always from client record (locked), ignore imported ones
    el("workLocation").value = data.workLocation || "";
    el("entryDate").value = data.entryDate || "";
    el("timeIn").value = data.timeIn || "";
    el("timeOut").value = data.timeOut || "";
    recalcTotalTime();

    setTasks(Array.isArray(data.tasks) ? data.tasks : []);
    setGoals(Array.isArray(data.goals) ? data.goals : []);

    el("additionalNotes").value = data.additionalNotes || "";

    // signatures + lock state
    formState.lockState = data.lockState || "unlocked";
    el("unlockName").value = data.unlock?.name || "";
    el("unlockAt").value = data.unlock?.at || "";

    // printed names
    el("clientPrinted").value = data.sigs?.client?.printed || "";
    el("coachPrinted").value  = data.sigs?.coach?.printed || "";
    el("specPrinted").value   = data.sigs?.spec?.printed || "";

    // signedAt + images
    formState.sigs.client.signedAt = data.sigs?.client?.signedAt || "";
    formState.sigs.coach.signedAt  = data.sigs?.coach?.signedAt || "";
    formState.sigs.spec.signedAt   = data.sigs?.spec?.signedAt || "";

    formState.sigs.client.dataUrl = data.sigs?.client?.dataUrl || "";
    formState.sigs.coach.dataUrl  = data.sigs?.coach?.dataUrl || "";
    formState.sigs.spec.dataUrl   = data.sigs?.spec?.dataUrl || "";

    el("clientSignedAt").textContent = formState.sigs.client.signedAt || "—";
    el("coachSignedAt").textContent  = formState.sigs.coach.signedAt  || "—";
    el("specSignedAt").textContent   = formState.sigs.spec.signedAt   || "—";

    setSigStatus("client", !!formState.sigs.client.signedAt);
    setSigStatus("coach", !!formState.sigs.coach.signedAt);
    setSigStatus("spec",  !!formState.sigs.spec.signedAt);

    sigPads.client.redraw();
    sigPads.coach.redraw();
    sigPads.spec.redraw();

    updateLockUI();
  }

  // ---- Autosave ----
  let saveTimer = null;
  function autosave() {
    clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      const cid = currentClientId();
      if (!cid) return;
      localStorage.setItem(storageKeyFor(cid), JSON.stringify(snapshot()));
      setSaveState("Saved", "good");
      setTimeout(() => setSaveState("Saved (idle)", ""), 800);
    }, 150);
  }

  function loadClientTemplate(client) {
    setPlanDatesLocked(client.planStart, client.planEnd);
    el("workLocation").value = client.workLocation || "";
    el("entryDate").value = todayISO();
    el("timeIn").value = "";
    el("timeOut").value = "";
    el("totalTime").value = "";
    el("additionalNotes").value = "";

    setTasks((client.tasks || DEFAULT_TASKS).map(t => ({ title: t, support: "", note: "" })));
    setGoals((client.goals || DEFAULT_GOALS).map(g => ({
      title: g,
      prompts: [{ code:"", count:1 }],
      note: ""
    })));

    // reset lock/sigs
    formState.lockState = "unlocked";
    el("unlockName").value = "";
    el("unlockAt").value = "";
    clearAllSignatures();

    updateLockUI();
    recalcTotalTime();
  }

  function loadSavedForClient(clientId) {
    const raw = localStorage.getItem(storageKeyFor(clientId));
    if (!raw) return false;
    try {
      const data = JSON.parse(raw);
      apply(data);
      return true;
    } catch {
      return false;
    }
  }

  function onClientChange() {
    const cid = currentClientId();
    const client = getClientById(cid);
    if (!client) {
      setSaveState("No client selected", "bad");
      return;
    }

    setPlanDatesLocked(client.planStart, client.planEnd);

    const loaded = loadSavedForClient(cid);
    if (!loaded) loadClientTemplate(client);

    setSaveState(loaded ? "Loaded saved entry" : "Loaded template", "good");
  }

  // ---- Client add/edit ----
  function addOrUpdateClient(existingId = null) {
    const clients = getClients();
    const existing = existingId ? getClientById(existingId) : null;

    const name = prompt("Client name:", existing?.name || "");
    if (!name) return;

    const planStartRaw = prompt("Plan Start (MM/DD/YYYY):", existing ? "" : "12/19/2025") || "";
    const planEndRaw   = prompt("Plan End (MM/DD/YYYY):", existing ? "" : "12/18/2026") || "";
    const planStart = normalizeToISO(planStartRaw);
    const planEnd   = normalizeToISO(planEndRaw);

    const workLocation = prompt("Work Location:", existing?.workLocation || "") || "";

    const tasksRaw = prompt(
      "Paste tasks (one per line). Leave blank to use defaults:",
      (existing?.tasks || DEFAULT_TASKS).join("\n")
    ) || "";
    const tasks = tasksRaw.split("\n").map(s => s.trim()).filter(Boolean);
    const finalTasks = tasks.length ? tasks : DEFAULT_TASKS.slice();

    const goalsRaw = prompt(
      "Paste goals (one per line). Leave blank to use defaults:",
      (existing?.goals || DEFAULT_GOALS).join("\n")
    ) || "";
    const goals = goalsRaw.split("\n").map(s => s.trim()).filter(Boolean);
    const finalGoals = goals.length ? goals : DEFAULT_GOALS.slice();

    if (existingId) {
      const idx = clients.findIndex(c => c.id === existingId);
      if (idx >= 0) clients[idx] = { ...clients[idx], name, planStart, planEnd, workLocation, tasks: finalTasks, goals: finalGoals };
      saveClients(clients);
      renderClientSelect(existingId);
      onClientChange();
      autosave();
      return;
    }

    const newClient = {
      id: "client_" + Math.random().toString(16).slice(2),
      name,
      planStart,
      planEnd,
      workLocation,
      tasks: finalTasks,
      goals: finalGoals
    };
    clients.push(newClient);
    saveClients(clients);
    renderClientSelect(newClient.id);
    onClientChange();
    autosave();
  }

  // ---- Template edit buttons (tasks/goals) ----
  function editTemplateTasks() {
    const cid = currentClientId();
    const client = getClientById(cid);
    if (!client) return;

    const current = (client.tasks || DEFAULT_TASKS).join("\n");
    const raw = prompt("Edit tasks template (one per line):", current);
    if (raw == null) return;

    const tasks = raw.split("\n").map(s=>s.trim()).filter(Boolean);
    client.tasks = tasks.length ? tasks : DEFAULT_TASKS.slice();

    const clients = getClients();
    const idx = clients.findIndex(c => c.id === cid);
    if (idx >= 0) clients[idx] = client;
    saveClients(clients);

    // apply template to current sheet too
    setTasks(client.tasks.map(t => ({ title:t, support:"", note:"" })));
    autosave();
  }

  function editTemplateGoals() {
    const cid = currentClientId();
    const client = getClientById(cid);
    if (!client) return;

    const current = (client.goals || DEFAULT_GOALS).join("\n");
    const raw = prompt("Edit goals template (one per line):", current);
    if (raw == null) return;

    const goals = raw.split("\n").map(s=>s.trim()).filter(Boolean);
    client.goals = goals.length ? goals : DEFAULT_GOALS.slice();

    const clients = getClients();
    const idx = clients.findIndex(c => c.id === cid);
    if (idx >= 0) clients[idx] = client;
    saveClients(clients);

    setGoals(client.goals.map(g => ({ title:g, prompts:[{code:"",count:1}], note:"" })));
    autosave();
  }

  // ---- Export/import ----
  function download(filename, text) {
    const blob = new Blob([text], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  function promptImport() {
    const raw = prompt("Paste exported JSON:");
    if (!raw) return;
    try {
      const data = JSON.parse(raw);
      apply(data);
      autosave();
      setSaveState("Imported", "good");
    } catch {
      alert("Invalid JSON. Try not to paste chaos next time.");
    }
  }

  // ---- Buttons + wiring ----
  ["workLocation","entryDate","additionalNotes","clientPrinted","coachPrinted","specPrinted","unlockName"].forEach(id => {
    el(id).addEventListener("input", autosave);
    el(id).addEventListener("change", autosave);
  });

  el("timeIn").addEventListener("input", () => { recalcTotalTime(); autosave(); });
  el("timeOut").addEventListener("input", () => { recalcTotalTime(); autosave(); });

  el("clientSelect").addEventListener("change", () => { onClientChange(); });

  el("addTask").addEventListener("click", () => { addTaskRow(el("tasksBody"), { title:"", support:"", note:"" }); autosave(); });
  el("addGoal").addEventListener("click", () => { addGoalRow(el("goalsBody"), { title:"", prompts:[{code:"",count:1}], note:"" }); autosave(); });

  el("addClient").addEventListener("click", () => addOrUpdateClient(null));
  el("editClient").addEventListener("click", () => {
    const cid = currentClientId();
    if (!cid) return;
    addOrUpdateClient(cid);
  });

  el("editTasks").addEventListener("click", () => {
    if (isLocked(formState.lockState)) return alert("Locked. Use PIN unlock to edit.");
    editTemplateTasks();
  });
  el("editGoals").addEventListener("click", () => {
    if (isLocked(formState.lockState)) return alert("Locked. Use PIN unlock to edit.");
    editTemplateGoals();
  });

  el("loadDemo").addEventListener("click", () => {
    const demo = [
      {
        id: "client_1",
        name: "Test Client A",
        planStart: "2025-12-19",
        planEnd: "2026-12-18",
        workLocation: "Albertsons",
        tasks: DEFAULT_TASKS,
        goals: DEFAULT_GOALS
      },
      {
        id: "client_2",
        name: "Test Client B",
        planStart: "2025-10-01",
        planEnd: "2026-09-30",
        workLocation: "Target",
        tasks: DEFAULT_TASKS,
        goals: DEFAULT_GOALS
      }
    ];
    saveClients(demo);
    renderClientSelect("client_1");
    onClientChange();
    autosave();
  });

  el("saveNow").addEventListener("click", () => {
    if (!blockIfInvalid("Save", { forAction:"save" })) return;
    const cid = currentClientId();
    if (!cid) return;
    localStorage.setItem(storageKeyFor(cid), JSON.stringify(snapshot()));
    setSaveState("Saved", "good");
  });

  el("exportJson").addEventListener("click", () => {
    if (!blockIfInvalid("Export", { forAction:"save" })) return;
    const data = snapshot();
    const safeName = (data.clientName || "client").replace(/[^a-z0-9]+/gi, "_").slice(0,40);
    const date = data.entryDate || todayISO();
    download(`TA_${safeName}_${date}.json`, JSON.stringify(data, null, 2));
  });

  el("importJson").addEventListener("click", promptImport);
  el("printPage").addEventListener("click", () => window.print());

  el("wipeAll").addEventListener("click", () => {
    if (!confirm("Wipe ALL locally saved data on this device (clients + entries)?")) return;
    localStorage.removeItem(CLIENTS_KEY);
    Object.keys(localStorage).forEach(k => {
      if (k.startsWith(STORAGE_KEY_BASE + ":")) localStorage.removeItem(k);
    });
    location.reload();
  });

  // ---- Signature pads hookup ----
  const sigPads = {
    client: createSigPad("clientCanvas", () => formState.sigs.client.dataUrl, (d)=>{ formState.sigs.client.dataUrl = d; }),
    coach:  createSigPad("coachCanvas",  () => formState.sigs.coach.dataUrl,  (d)=>{ formState.sigs.coach.dataUrl  = d; }),
    spec:   createSigPad("specCanvas",   () => formState.sigs.spec.dataUrl,   (d)=>{ formState.sigs.spec.dataUrl   = d; })
  };

  el("clientClear").addEventListener("click", () => { formState.sigs.client.dataUrl=""; formState.sigs.client.signedAt=""; sigPads.client.clear(); el("clientSignedAt").textContent="—"; setSigStatus("client", false); autosave(); });
  el("coachClear").addEventListener("click", () => { formState.sigs.coach.dataUrl="";  formState.sigs.coach.signedAt="";  sigPads.coach.clear();  el("coachSignedAt").textContent="—";  setSigStatus("coach", false); autosave(); });
  el("specClear").addEventListener("click",  () => { formState.sigs.spec.dataUrl="";   formState.sigs.spec.signedAt="";   sigPads.spec.clear();   el("specSignedAt").textContent="—";   setSigStatus("spec", false); autosave(); });

  el("clientSign").addEventListener("click", () => {
    if (formState.lockState === "final") return alert("FINAL locked. No changes allowed.");
    if (!blockIfInvalid("Client Sign", { forAction:"clientSign" })) return;

    formState.sigs.client.signedAt = nowStamp();
    el("clientSignedAt").textContent = formState.sigs.client.signedAt;
    setSigStatus("client", true);

    // Lock editing after client signs
    formState.lockState = "locked";
    updateLockUI();
    autosave();
  });

  el("coachSign").addEventListener("click", () => {
    if (formState.lockState === "final") return alert("FINAL locked. No changes allowed.");
    if (!blockIfInvalid("Coach Sign", { forAction:"coachSign" })) return;

    formState.sigs.coach.signedAt = nowStamp();
    el("coachSignedAt").textContent = formState.sigs.coach.signedAt;
    setSigStatus("coach", true);

    autosave();
  });

  el("specFinal").addEventListener("click", () => {
    if (formState.lockState === "final") return alert("Already FINAL locked.");
    if (!blockIfInvalid("Specialist Final Sign-Off", { forAction:"specFinal" })) return;

    formState.sigs.spec.signedAt = nowStamp();
    el("specSignedAt").textContent = formState.sigs.spec.signedAt;
    setSigStatus("spec", true);

    formState.lockState = "final";
    updateLockUI();
    autosave();
  });

  // ---- Unlock workflow ----
  el("unlockBtn").addEventListener("click", () => {
    if (formState.lockState === "final") return alert("FINAL locked. No unlock allowed.");
    if (formState.lockState !== "locked") return alert("Not locked. Nothing to unlock.");

    const pin = el("unlockPin").value || "";
    if (pin !== PIN_DEFAULT) return alert("Wrong PIN.");

    if (!el("unlockName").value.trim()) return alert("Enter Specialist Name for unlock log.");

    // unlocking clears signatures (per your rule)
    clearAllSignatures();

    formState.lockState = "unlocked";
    el("unlockAt").value = nowStamp();
    updateLockUI();
    autosave();
  });

  el("relockBtn").addEventListener("click", () => {
    if (formState.lockState === "final") return alert("FINAL locked.");
    if (formState.lockState !== "unlocked") return alert("Already locked.");

    // Re-lock after edits (still no signatures since unlock cleared them)
    formState.lockState = "locked";
    updateLockUI();
    autosave();
  });

  // ---- Init ----
  (function init() {
    renderClientSelect();
    const clients = getClients();
    if (clients.length) {
      renderClientSelect(clients[0].id);
      onClientChange();
      setSaveState("Ready", "good");
    } else {
      setPlanDatesLocked("", "");
      setSaveState("No clients loaded (use Add Client or Load Demo Clients)", "bad");
    }

    updateLockUI();
  })();
</script>
</body>
</html>
